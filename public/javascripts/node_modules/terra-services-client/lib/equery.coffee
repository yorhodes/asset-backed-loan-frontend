class equery
  block_time: 17
  block_time_ms: 17000
  config:
    node:
      ip: "127.0.0.1"
      port: "8545"

  constructor: ()->
    W3 = require "web3"
    if @web3?
      @web3 = new W3 web3.currentProvider
    else
      @web3 = new W3 new W3.providers.HttpProvider @node_address @config.node.ip, @config.node.port
    throw "could not connect to ethereum node on localhost. exiting" if !this.web3.isConnected()

    @eth = this.web3.eth;
    @coinbase = this.eth.coinbase
    for name,data of @contracts
      @["_"+name] = @contract data
      @[name] = @contract_agent(name)
    for name,address of @users
      @[name] = @user_agent address
    @events_fired = []

  user_agent: (address)->
    global = @
    user = {}
    user.address = address
    user.send = (value,callback = (txid)-> console.log(txid))->
      tx =
        from: global.account(),
        to: @.address,
        value: value
      global.eth.sendTransaction tx,(error,txid)-> global.check_mined(txid,callback)

    return user

  contract_agent: (contract_name)->
    _contract_name = "_"+contract_name
    agent = {}
    for routine in @[_contract_name].abi
      if routine.type == "event" or routine.type == "function"
        agent[routine.name] = {}

        #console.log routine.constant

        agent[routine.name] = switch
          when routine.type is "event" then @create_listener(_contract_name,routine.name)
          when routine.type is "function" then @create_method(_contract_name,routine.name,routine.constant)
    agent.address = @[_contract_name].address
    agent.get_balance = ()=> @decode @eth.getBalance agent.address
    return agent

  create_listener: (contract_name,routine_name)=>
    return listen:(callback)=>
      @[contract_name][routine_name].listen (args...,job)=>
        #register event as heard
        hash = @web3.sha3 @encode job

        if hash not in @events_fired
          @events_fired.push hash
          callback(args...,job)
        else
          console.log "doublefire",hash
  create_method: (contract_name,routine_name,is_constant)->
    if is_constant
      return (args...,callback)=> @[contract_name][routine_name].local(args...,callback)
    else
      return (params...)=>        #0 params?
        if params.length == 0
          console.error "Please call with a callback specified"
          @[contract_name][routine_name].remote (results...)-> console.log results...
        else if params.length == 1
          @[contract_name][routine_name].remote(params[0]) #just callback -> must be .remote
        else
          if typeof params[0] == "object"
            @[contract_name][routine_name].send params...
          else
            @[contract_name][routine_name].remote params...

  clean_return_value: (value)->
    try
      decoded = @decode value
    catch error
      decoded = value
    return decoded

  contract: (data) ->

    #return container object for this that has syntax @contract.myMethod args...,(ret1,ret2)-> console.log ret2
    #check for constant keyword and then automatically choose .local. Else choose .remote or .send depending on presense of spec object.

    _address = data.address
    _interface = data.interface
    c = @eth.contract(_interface).at(_address)
    for routine in c.abi
      global = @ if routine.type == "event" or routine.type == "function"
      if routine.type == "event"
        c[routine.name].listen = (callback)->
          e = @ (error,job)->
            console.log "error:",error if error
            values = []
            for key in Object.keys(job.args)
              values.push global.clean_return_value job.args[key]
            callback(values...,job.transactionHash,job)                         #this listen never ends? rebuild as _callback?
          return stop: ()-> e.stopWatching()

      if routine.type == "function"

        c[routine.name].method = routine.name

        #local vm call
        c[routine.name].local = (args..., callback)->
          @.call args...,(error,data)=>
            return console.error error if error?
            try
              decoded = global.decode data
              callback(decoded)
            catch e
              values = []
              for datum in data
                values.push global.clean_return_value datum
              callback(values...)

        #remote call with some value (transaction)
        c[routine.name].send = (specification,args...,callback)->
          callback_event_name = @.method + "_callback"
          if callback_event_name of c
            callback_event = c[callback_event_name]()
            global.remote_transaction(global,c.address,@,specification,{returns:true,event:callback_event},args...,callback)
          else
            global.remote_transaction(global,c.address,@,specification,{returns:false},args...,callback)

        #remote call without value
        c[routine.name].remote = (args...,callback)->
          callback_event_name = @.method + "_callback"
          if callback_event_name of c
            callback_event = c[callback_event_name]()
            global.remote_transaction global,c.address,@,{},{returns:true,event:callback_event},args...,callback
          else
            global.remote_transaction(global,c.address,@,{},{returns:false},args...,callback)

    return c

  remote_transaction: (global,address,method,specification,end,args...,callback)->

    parameters = method.getData args...
    value = if "value" of specification then specification.value else 0
    gas = if "gas" of specification then specification.gas else global.eth.estimateGas to: address,data: parameters

    tx =
      from: global.account(),
      to: address,
      value: value,
      data: parameters
      gas: gas
    global.eth.sendTransaction tx,(error,txid)->
      return console.log "Could not execute transaction",error if error?

      if end.returns
        end.event.watch (error,job)->
          return console.log "error:",error if error
          event_txid = job.transactionHash
          return if event_txid != txid      #bad event
          end.event.stopWatching()          #turn off
          values = []
          values.push(job.args[key]) for key in Object.keys(job.args)
          callback(values...,txid)
      else
        global.check_mined(txid,callback)

  check_mined: (txid,callback)->
    @.eth.getTransactionReceipt txid,(error, receipt)=>
      if receipt?
        @.eth.getTransaction receipt.transactionHash,(error, tx)=>
          receipt[key] = value for key,value of tx
          callback(txid,receipt)
      else
        @timeout 1000,()=> @check_mined(txid,callback)

  create_account: (address)->
    c = {}
    c.send = (amount,callback)->
        tx = from: @account,to:address,value:amount,gas:2000000
        @eth.sendTransaction tx,(error,txid)->
          return console.log error if error
          callback(txid)
    return c

  http: (url,callback)->
    @request_http = require 'request'
    @request_http url, (error, response, body)-> callback response.body if !error && response.statusCode == 200

  timeout: (wait,target) -> setTimeout (-> target()), wait
  decode: (i) -> JSON.parse i
  encode: (i) -> JSON.stringify i
  node_address: (ip,port) -> return "http://" + ip + ":" + port
  accounts: () -> this.eth.accounts
  account:() -> this.eth.accounts[0]
  random_int: (max,min=0) -> Math.floor(Math.random() * (max - min) + min)
  sec_to_ms: (sec) -> sec*1000
  now: ()-> Math.round(new Date().getTime()/1000)

module.exports = equery
